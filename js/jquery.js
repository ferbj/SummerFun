/ *! jQuery v1.11.3 | (c) 2005, 2015 jQuery Fundación, Inc. | jquery.org/license * /
! la función (a, b) {"objeto" == módulo typeof && "objeto" == typeof module.exports module.exports = a.document b (a, 0!):?! función (a) {if (un .document) throw new Error ("jQuery requiere una ventana con un documento"); b retorno (a)}:!? b (a)} ("undefined" = ventana typeof ventana: esto, la función (a, b) { var nuevo d.call (este)}, obtener: function (a) {return null = a 0> a esto [a + this.length]:?!? esta [a]: d.call (este)}, pushStack: función (a) {var b = m.merge (this.constructor (), a); volver b.prevObject = esto, b.context = this.context, b}, cada uno: la función (a, b) {return m. cada uno (esto, a, b)}, el mapa: función (a) {return this.pushStack (m.map (esto, la función (b, c) {return a.call (b, c, b)}))} , rebanada: function () {return this.pushStack (d.apply (este, argumentos))}, primero: function () {return this.eq (0)}, última: function () {return this.eq (- 1)}, eq: function (a) {var b = this.length, c = + a + (0> a b:? 0), volver this.pushStack (c> = 0 && b> c [este [c]] : [])}, final: function () {return a, b, c, d, e, f, g = argumentos [0] || {}, h = 1, i = arguments.length, j = 1;! a ("booleano" == typeof g && (j = g, g = argumentos [h] || {}, h ++), "objeto" == typeof g || m.isFunction (g) || (g = {}), h === i && (g = esto, h -); i> h; h ++) si (null = (e = argumentos [h])) de (d adentro! 0 == c && (g [d] c =)); retorno g}, m.extend ({expando: "jQuery" + (l + Math.random ()) en lugar de (/ \ D / g, "". ), isReady: 0, error: function (a) {throw new b; for (b en a) devuelve 1; return 0}, isPlainObject: función (a) {var! en a) j.call retorno (a, b), porque (b en a); volverá vacía j.call 0 === b || (a, b)}, escriba: función (a) {return null == A A + "?": "Objeto" == typeof a || "función"? == typeof h a [i.call (a)] || "objeto": typeof a.replace (o, "ms -") reemplazar (p, q)}, nodeName: function (a, b) {return a.nodeName && a.nodeName.toLowerCase () === b.toLowerCase ()}, cada uno. : function (a, b, c) {var d, e = 0, f = a.length, g = r (a), si (c) {if (g) {for (; f> e; e ++) si (d = b.apply (a [e], c), d ===! 1) ruptura} else for (e en a) si (d = b.apply (a [e], c), d == ! = 1) ruptura} else if (g) {for (; f> e; e ++) si (d = b.call (a [e], e, a [e])!, d === 1) Salto } else for (e en a) si (d = b.call (a [e], e, a [e]), d === 1!) rompa; volver a}, recorte: función (a) {return nula == un "" :( a + "") reemplazará (n, "")}, MakeArray:?.! la función (a, b) {var c = b || []; devolver null && = a (r (Object ? (a)) m.merge (c, "cadena" == typeof un [a]: a): f.call (c, a)), c}, InArray: function (a, b c,) { var d, y si (b) {if (g) g.call retorno (b, a, c);?? a (d = b.length, c = c 0> c Math.max (0, d + c) : c: 0; d> c, c ++) si (c en b && b [c] === a) la devolución c} return-1}, fusionar: function (a, b) {var c = + b.length, d = 0, e = a.length, mientras que (c> d) a [e ++] = b [D] ++; if (! c == c) while (! nula 0 == b [d]) a [e ++] = b [D ++]; a.length retorno = e, a}, grep: función (a, b, c) {for (var d, e = [], f = 0, g = a.length, h = c ; g> f; f ++) d = b (a [f], f), d == h && e.push (a [f]); retorno e}, el mapa:! la función (a, b, c) {var d, f = 0, g = a.length, h = r (a), i = []; si (h) para (; g> f; f ++) d = b (a [f], f, c) , null = d && i.push (d);! else for (f en a) b = d (a [f], f, c), null = d && i.push (d);! volver e.apply ([], i)}, guid: 1, delegación: function (a, b) {var c, e, f, volver "cadena" == typeof b && (f = a [b], b = a, a = f), m .isFunction (a)? (c = d.call (argumentos, 2), e = function () {return a.apply (b || esto, c.concat (d.call (argumentos)))}, e. guid = a.guid = a.guid || m.guid ++, e): void 0}, ahora: function () {return + nueva fecha}, el apoyo: k}), m.each ("Función de Array Número de Boole Cadena Fecha RegExp objeto Error ".split (" "), la función (a, b) {h [" [objeto "+ b +"] "] = b.toLowerCase ()}); la función r (a) {var b =" longitud "en b && b> 0 && b-1 en una} var s = function (a) {var b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r , s, t, u = "chisporroteo" + 1 * new Date, v = a.document, w = 0, x = 0, y = ha (), z = ha (), A = ha (), B = función (a, b) {return c = 0, d = a.length; d> c, c ++) si (a [c] === b) la devolución RegExp (L + "+", "g"), R = new RegExp ("^" + L + "+ | ((:? ^ | [^ \\\\]) (: \\\\) *)?. "+ L +" + $ "," g "), S = new RegExp (" ^ "+ L +" * "+ L +" * "), T = new RegExp (" ^ "L + +" * ([> + ~] | "+ L +") "L + +" * "), U = new RegExp (" = "L + +" * ([^ \\] '\ L + + "* \\]" "] *)?" , "g"), V = new RegExp (P), W = new RegExp ("^" + N + "$"), X = {ID: nueva RegExp ("^ # (" + M + ")"), CLASE : nueva RegExp ("^ \\ (". + M + ")"), TAG: nueva RegExp ("^ (" + M.replace ("w", "w *") + ")"), attr: nueva RegExp ("^" + O), PSEUDO: nueva RegExp ("^" + P), NIÑO: nueva RegExp ("^ (?:" + K + ") $", "i"), needsContext: nueva \ w /, _ = / ^ (:? # ([\ w -] +) | (\ w +) | \ ([\ w -] +).) $ /, aa = / [+ ~] /, ba = / '| \\ / g, ca = new RegExp ("\\\\ ([\\ da-f] {1,6}" + L + "|? (" L + + ") |.)", " ig "), da = function (a, b, c) {var d =" 0x "+ b-65536; retorno c = a.length, d = 0, mientras que (a [c ++] = b [d ++]); a.length = c-1}}} ga función (a, b, d, e) {var a ||! a || 1! == k && 9! == k && 11! == k) de retorno d; si (h.id === j) la devolución d.push (h), d} else if (b.ownerDocument && (h = b.ownerDocument.getElementById (j)) && t (b, h) && h.id = == j) d.push retorno (h), d} else {if (f [2]) volver H.apply (d, b.getElementsByTagName (a)), d; if ((j = f [3]) && c.getElementsByClassName) de retorno H.apply (d, w.querySelectorAll (x)), d} catch (y) {} finally {r || b.removeAttribute ("id")}}} return i (a.replace (R, "$ 1" ), b, d, e)} function ha () {var a = []; la función b (c, e) {a.push retorno (c + "")> d.cacheLength && eliminar b [a.shift ()], b [c + ""] = e} return b} function ia (a) {return un [u] = 0, a} ja función (a) {var ka (a, b) {var c = a.split ("|"), e = a.length, mientras que (e -) d.attrHandle [c [e]] = b} function la (a, b) {var c = b && a, d = c && 1 === a.nodeType && 1 === b.nodeType && (~ b.sourceIndex || C) - (~ a.sourceIndex || C), si (d) la devolución d; si ( c) mientras (c = c.nextSibling) si (c === b) devuelven-1; devolver un 1: -1} ma función (a) {retorno de la función (b) {var c = b.nodeName.toLowerCase (); return "entrada" === c && b.type === a}} funcionar na (a) {retorno de la función (b) {var c = b.nodeName.toLowerCase (); return ("entrada" === "botón" c || === c) && b.type === a}} oa la función (a) {return ia (function (b) {return b = + b, ia (function (c, d) {var e, f = a ([], c.length, b), g = f.length;! while (g -) c [e = f [g]] && (c [e] = (d [e] = c [e]))})})} function pa (a) {return un && "undefined"! = typeof a.getElementsByTagName && a} c = ga.support = {}, f = ga.isXML = function (a) { var b = a && (a.ownerDocument || a) .documentElement; retorno b "HTML" == b.nodeName:?!! 1}, m = ga.setDocument = function (a) {var b, e, g = ? un a.ownerDocument || a: v; retorno a.className = "i",! a.getAttribute ("className")}), c.getElementsByTagName = ja (function (a) {return b.getElementById && p) {var c = b.getElementById (a); [c] retorno c && c.parentNode: []}}, d.filter.ID = function (a) {var b = a.replace (ca, da ); la función de retorno (a) {return a.getAttribute ("id") === b}}) :( eliminar d.find.ID, d.filter.ID = function (a) {var b = a.replace (ca, da); la función de retorno (a) {var c = "undefined" = typeof a.getAttributeNode && a.getAttributeNode ("id");! devolver c && c.value === b}}), d.find.TAG = c.getElementsByTagName función (a, b) {return "indefinido" = typeof b.getElementsByTagName b.getElementsByTagName (a):?!? c.qsa b.querySelectorAll (a): void 0}: la función (a, b) {var c, d = [], e = 0, f = b.getElementsByTagName (a), si ("*" === a) {while (c = f [e ++]) 1 === c.nodeType && d. push (c); retorno d} return f}, d.find.CLASS = function c.getElementsByClassName && (a, b) {return p b.getElementsByClassName (a): void 0}, r = [], q = [] , (c.qsa = $. de prueba (g.querySelectorAll)) && (ja (función (a) {o.appendChild (a) .innerHTML = "<a id='"+u+"'> </a> < seleccione id = '"+ u +" - \ f]' msallowcapture = ''> <option RegExp (q.join ("|")), r = r.length && nueva RegExp (r.join ("|"))., B = $ prueba (o.compareDocumentPosition), t = b || $ .test (o ?? .contains) función (a, b) {var c = 9 === a.nodeType a.documentElement: a, d = b && b.parentNode; retorno l = 0,0;!!! var d = a.compareDocumentPosition- b.compareDocumentPosition; retorno l = 0,0;! var c, d = 0, e = a.parentNode, f = b.parentNode, h = [a], i = [b]; (! e || f) si volver a = ?? == g -1: b === g 1: e -1: f 1: k J (k, a) -J (k, b):??? 0; si (e === f) regreso d la (h [d], i [d]): h [d] === v -1:?? i [d] === v 1: 0}, g): n}, ga.matches = function (a, b) {return d = s.call (a, b); if (! d || c.disconnectedMatch || a.document && 11 == a.document.nodeType) retorno d} catch (e) {} return e = d.attrHandle [b.toLowerCase ()], f = e && D.call (d.attrHandle, b.toLowerCase ()) e (a, b, p!): void 0; retorno vacío nuevo error ("Error de sintaxis, la expresión no reconocido:" + a)}, ga.uniqueSort = function (a) {var k = null, a}, e = ga.getText = function (a) {var b, c = "", d = 0, f = a.nodeType; si (f) {if (1 === f || 9 === f || 11 === f) {if ("cadena" == typeof a.textContent) volver a.textContent; para (a = a.firstChild; a; a = a.nextSibling) c + = e (a)} else if (3 === f || 4 === f) volver a.nodeValue} else while (b = a [d ++]) c + = e (b); retorno a [1] = a [1] .Colocar (ca, da), un [3] = (a [3] || un [4] || un [5] || ""). replace (ca, da ), "~ =" === un [2] && (a [3] = "" + a [3] + ""), a.slice (0,4)}, NIÑO: function (a) {return b, c = a [6] && un [2];! devolución b = a.replace (ca, da) .tolowercase (); return "*" === una función () {return 0!}: function (a) {return a.nodeName && a.nodeName.toLowerCase () ==? = b}}, CLASE: function (a) {var b = y [a + ""]; retorno b || (b = new RegExp ("(^ |" + L + ")" + a + "(" + L + " | $) ")) && y (a, la función (a) {return b.test (" cadena "== typeof a.className && a.className ||" indefinido de clases ")" = typeof a.getAttribute && a.getAttribute (! "| | "")})}, ATTR: function (a, b, c) {función de retorno (d) {var e = ga.attr (d, a); retorno "+ e.replace (Q," ") +" ! f = "enésima" == a.slice (0,3), g = "último" == a.slice (-4), h = "del tipo" === b;! devolver 1 === ? d && 0 === e función (a) {return !! a.parentNode}: function (b, c, i) {var si (s && (j = (b [u] || (b [u] = {})) [a]) && j [0] === w) m = j [1]; lo demás m- = e, m === d || m% d === 0 && m / d> = 0}}}, PSEUDO: function (a, b) {var c, e = d.pseudos [a] || d.setFilters [a.toLowerCase ()] || ga.error ("pseudo sin apoyo:" + a);?? vuelta de correo [u] e (b): e.length> 1 (c = [a, a, "", b], d.setFilters.hasOwnProperty (a.toLowerCase ()) ia (function (a, c) {var d, f = e (a, b), g = f.length;? while (g- -) d = J (a, f [g]), un [d] = (c [d] = f [g])}): function (a) {return correo (a, 0, c)})! : e}}, pseudos: {No: ia (function (a) {var b = [], c = [], d = h (a.replace (R, "$ 1")); retorno d [u]? ia (función (a, b, c, e) {var f, g = d (a, null, e, []), h = a.length; while (h -) (f = g [h]) && (a [h] = (b [h] = f)!)}): function (a, e, f) {return b [0] = a, d (b, null, f, c), b [ 0] = null, c.pop ()}}), cuenta con: ia (function (a) {retorno de la función (b) {ga retorno (a, b) .length> 0}}), contiene: ia (función (un retorno W.test (a || "") || ga.error ("sin soporte lang:" + a), a = a.replace (ca, da) .tolowercase (), función (b) {var c; hacer si (c = p b.lang:? b.getAttribute ("xml: lang") || b.getAttribute ("lang")) return c = a.location && a.location.hash; regresar c && c.slice (1) === b.id}, raíz: function (a) {return una o ===}, enfoque: función (a) {return ! a.disabled === 1}, discapacitados: function (a) {return a.disabled === 0}, comprobado: la función (a) {var Z.test (a.nodeName)}, de entrada: function (a) {return Y.test (a.nodeName)}, un botón: function (a) {var b = a.nodeName.toLowerCase (); return "de entrada" === b && "botón" === a.type || "botón" === b}, texto: function (a) {var c = 0; b> c; c + = 2) a.push (c); volver a}), impar: OA (function (a, b) {for (var c = 1; b> c; c + = 2) a.push (c); volver a}), lt: o (function (a, b, c) {for (var d = 0> c c + b: c; - d> = 0;) a. push (d); volver a}), gt: o (function (a, b, c) {for (var d = 0> c c + b: c; ++ d <b;) a.push (d ); volver a})}}, d.pseudos.nth = d.pseudos.eq; for (b {en la radio:!!!!! 0, casilla: 0, archivo: 0, contraseña: 0, imagen: 0 }) d.pseudos [b] = ma (b), por (b en {presentar: 0, reset: 0}) d.pseudos [b] = na (b); la función qa () {} qa. prototipo = d.filters = d.pseudos, d.setFilters = new qa, g = ga.tokenize = function (a, b) {var c, e, f, g, h, i, j, k = z [a + ""]; si (k) de retorno ")}), h = h.slice (c.length)); for (g en ? b h.length: h ga.error (a): z (a, i) .slice (0)}; función ra (a) {for (var b = 0, c = a.length, d = " "; c> b; b ++) d + = a [b] .value; retorno d} sa función (a, b, c) {var d = b.dir, e = c &&" parentNode "=== d, f = x ++; volver b.first función (b, c, f) {while (b = b [d]) si (1 === b.nodeType || e) volver a (b, c, f)}: función? (b, c, g) {var h, i, j = [w, f]; si (g) {while (b = b [d]) if ((1 === b.nodeType || e) && un (b, c, g)) devuelven 0} else while (b = b [d]) si (1 === b.nodeType || e) {if (i = b [u] || (b [u ] = {}), (h = i [d]) && h [0] === w && h [1] === f) la devolución j [2] = h [2]; si (i [d] = j, j [2] = a (b, c, g)) return 0}}} function ta (a) {a.length retorno> 1 función (b, c, d) {var e = a.length;!?, mientras que (e -) si volver 1; return 0} (a [e] (b, c, d)!):! a [0]} function ua (a, b, c) {for (var d = 0 , e = b.length; e> d; d ++) ga (a, b [d], c); retorno c} va de función (a, b, c, d, e) {for (var f, g = [ !], h = 0, i = a.length, j = null = b; i> h; h ++) (! f = a [h]) && (c || c (f, d, e)) && ( g.push (f), j && b.push (h)); retorno g} wa función (! a, b, c, d, e, f) {return d && d [u] && (d = wa (d)) , e &&! e [u] && (e = wa (e, f)), ia (function (f, g, h, i) {var r = VA (r === g r.splice (o, r.length):? r), correo electrónico (null, g, r, i):? H.apply (g, r)})} function xa (a) {for (var b, c, e, f = a.length, g = d.relative [a [0] .type], h = g || d.relative [""], i = g? 1: 0, k = sa (! función (a) {return un === b}, h, 0), L = sa (function (a) {return J (b, a)> - 1}, h, 0), m = [función (a, c, d) {var e =! g && (d || c! == j) || ((b = c)? k .nodeType (a, c, d) : l (a, c, d)); retorno wa (i> 1 && ta (m), i> 1 && ra (a.slice (0, i-1) .concat ({valor: " ta (m)} function ya (a, b) {var c = b.length> 0, e = a.length> 0, f = function (f, g, h, i, k) {var k && (w = v, j = t), r}; retorno c ia (f): f} return h = ga.compile = function (a, b) {var c, d = [], e = [] , f = A [a + " f}, i = ga.select = function (a, b, e, f) {var i, j, k, l, m, n = "función" == typeof 1 & a.compareDocumentPosition (n.createElement ("div"))}), ja (function (a) {return a.innerHTML = "<a ? c nula 0: a.getAttribute (b, "tipo" === b.toLowerCase () 1: 2)}), c.attributes && ja (function (a) {return c || "entrada" == a.nodeName.toLowerCase () void 0:!? a.defaultValue}), ja (function (a) {return null == a.getAttribute ("disabled")}) || ka (K, la función (a, b, c) {var d; c retorno vacío? t = m.expr.match.needsContext, u = / ^ <? (\ w +) \ s * \ /> (:? <\ / \ 1> |) $ /, v = / ^ [^:. # \ [\,.] * $ /; la función w (a, b, c) {if (m.isFunction (b)) m.grep retorno (a, la función (a, d) {return !! b.call (un , d, a) == c}); if (! b.nodeType) m.grep retorno (a, la función (a) {return una === b == c}); if (! "cadena" == typeof b) {if (v.test (b)) m.filter retorno (b, a, c); b = m.filter (b, a)} m.grep retorno (a, la función (a) {return m .inArray (a, b)> = 0 == c})} m.filter = function (a, b, c) {var d = b [0];! devolución 1 === a.nodeType}))}, m.fn.extend ({encontrar: function (a) {var b, c = [], d = este, e = D.Longitud; si ("cadena"! = typeof a) la devolución c = this.pushStack (? e> 1 M.Unique (c): c), c.selector = this.selector this.selector + "" + a:? a, c}, filtro: la función (a) {return este .pushStack (w (esto, a || [] ,! 1))}, no: la función (a) {return this.pushStack (w (esto, a || [] ,! 0))}, es: la función (a) {return !! w (this, "cadena" == typeof un && t.test (a) m (a):? a || [] ,! 1) .length}}); var x, y = a .document, z = / ^ (?: \ s * (<[\ w \ W] +>) [^>] * | # ([\ w -] *)) $ /, A = m.fn.init = function (a, b) {var c, d; (! a) cuando regrese esta; si ("cadena" == typeof en vez de en b) m.isFunction (esto [c]), este [c] (b [c]):? this.attr (c, b [c]); devuelva este} if (d = y.getElementById (c [2 ]), d && d.parentNode) {if (c == d.id [2]) x.find retorno (a);! this.length = 1, esto [0] = d} volver this.context = y, de este .Selector = a, esto} return a.nodeType (this.context = esta [0] = a, this.length = 1, este):?! m.isFunction (a) "indefinido" = typeof x.ready? x.ready (a): una (m) :( vacío d = [], e = a [b];!!! while (e && 9 == e.nodeType && (void 0 === c || == 1 || e.nodeType m (e) .es (c)) ) 1 === e.nodeType && d.push (e), e = e [b]; retorno d}, hermano: function (a, b) {for (var c = []; a; a = a.nextSibling) ! 1 === a.nodeType && a == b && c.push (a); retorno c}}), m.fn.extend ({tiene: function (a) {var b, c = m (a, este), d = c.length; retorno c, d = 0, e = this.length, f = [], g = t.test (a) || "cadena"! = typeof this.pushStack (f.length> 1 M.Unique (f): f)}, índice: function (a) {return una "cadena" == typeof? añadir: function (a, b) {return this.pushStack (M.Unique (m.merge (this.get (), m (a, b))))}, addBack: function (a) {return this.add (null == un this.prevObject:? this.prevObject.filter (a))!}}); la función D (a, b) hacer {a = a [b], mientras que (a && 1 == a.nodeType); volver a} m.each ({padre: function (a) {var b = a.parentNode; retorno b && 11 == b.nodeType b:!? null}, los padres: la función (a) {m.dir retorno (a, "parentNode")}, parentsUntil: function (a, b, c) {return m.dir (a, "parentNode", c)}, al lado: function (a) {return D (a, "nextSibling")}, prev: function (a) {return D (a, "previousSibling")}, nextAll: function (a) {return m.dir (a, "nextSibling")}, prevAll: function (a) {m.dir retorno ( un "previousSibling")}, nextUntil: function (a, b, c) {m.dir retorno (a, "nextSibling", c)}, prevUntil: function (a, b, c) {m.dir retorno ( un "previousSibling", c)}, hermanos: function (a) {return m.sibling ((a.parentNode || {}) firstChild, a)}, los niños:. función (a) {return m.sibling ( a.firstChild)}, contenidos: function (a) {return e = m.map (esto, b, c);! retorno "Hasta" == a.slice (-5) && (d = c), d && "cadena" == typeof E = / \ S + / g, F = {}; función G (a) {var b = F [a] = {}; m.each retorno (a.match (E) || [], la función (a, c) {b [c] = 0!}), b} m.Callbacks = function (a) {a = "cadena" == typeof un F [a] || G (a):? m.extend ({ }, a); var d = h.length;! función f (b) {m.each (b, la función (b, c) {var esto}, remover: function () {return h && m.each (argumentos, la función (a, c) {var ? un m.inArray (a, h)> - 1: (! h || h.length)}, vacío: function () {return h = [], e = 0, esto}, desactivar: function ( ) {return h = i = c = 0 nula, esto}, discapacitados: function () {! volver h}, cerradura: function () {return i = vacío k.fireWith (este, argumentos), esto}, disparó: function () {return !! d}}; retorno k}, m.extend ({Diferido: function (a) {var b = [["determinación", "hecho", m.Callbacks ("una vez que la memoria"), "resuelto"], ["rechazar", "quebrar", m.Callbacks ("una vez c}, siempre: function () {return e.done (argumentos) .fail (argumentos), esto}, a continuación: function () {var a = argumentos; regresan m.Deferred (function (c) {m.each ( b, la función (b, f) {var = g m.isFunction (a [b]) && un [b]; e [f [1]] (function () {var null = un m.extend (a, d): d}}, e = {}; volver d.pipe = d.then, m.each (b, la función (a, f) {var!? Array (e), j = new Array (e), k = new f || g.resolveWith (k, c), g.promise ()}}); var H; m.fn.ready = function (a) {return c = 1;! try {c = null == a.frameElement && y.documentElement} catch (d) {} ​​c && c.doScroll && función e () {if (! m.isReady) {try {c.doScroll ("izquierda" )} catch (a) {return setTimeout (e, 50)} I (), m.ready ()}} ()} volver H.promise (b)}; var K = "undefined", L; for (L en m (k)) break;! k.ownLast = "0" == L, k.inlineBlockNeedsLayout = 1, m (function () {var a = y.createElement ("div"), si (null == k.deleteExpando) {k.deleteExpando = 0;! try {eliminar a.test} catch (b) {k.deleteExpando = 1}} a = null} (), m.acceptData = function (a) {var b = m.noData [(a.nodeName + "") .tolowercase ()], c = + a.nodeType || 1;! devolver 1 == c && 9 ! == c 1: b || b == 0 && a.getAttribute ("classid") === b}; var M = / ^ (?:!!!!? \ {[\ w \ W] * \} | \ [[\ w \ W] * \]) $ /, N = / ([AZ]) / g; la función O (a, b, c) {if (void 0 === c && 1 === a. nodeType) {var d = "datos -" + b.replace (N ", - $ 1") toLowerCase ();. si (c = a.getAttribute (d), "cadena" == typeof c = nula 0} return c} función P (a) {var b; for (b en a) si (("datos" == b || m.isEmptyObject (a [b])) && "toJSON"! ! == b) devuelven 1!;

volver 0} función Q (a, b, d, e) {if (m.acceptData (a)) {var f, g, h = m.expando, i = a.nodeType, j = i? m.cache : a, k = i una [h]:?! a [h] && h; si (k && j [k] && (e || j [k] .data) || vacío 0 == d || "cadena"! = typeof b) la devolución k || (k = i una [h] = c.pop (?) || m.guid ++: h), j [k] || (j [k] = i {}: { toJSON: m.noop}), ("objeto" == typeof b || "función" == typeof 0! == D && (g [m.camelCase (b)] = d), "cadena" == typeof B? (F = g [b], null == f && (f = g [m.camelCase (b) ])): f = g, f}} function R (a, b, c) {if (m.acceptData (a)) {var en d b = [b] :( b = m.camelCase (b), b = b en d [b]:?? b.split ("")), e = b.length; while (E--) Eliminar d [b [e]]; si (?! c P (d) :! m.isEmptyObject (d)) return} (c || (borrar g [h] .data, P (g [h])) ) && (f m.cleanData ([a] ,! 0?): k.deleteExpando || g = g.window eliminar g [h]: g [h] = null)}}} m.extend ({ cache: {}, NoData: {"Applet": 0, "embed": 0, "objeto": "clsid: D27CDB6E-AE6D-11cf-96B8-444553540000"}, HasData: function (a) {return un = a.nodeType m.cache [a [m.expando]]:?! A [m.expando], !! a && P (a)}, los datos: function (a, b, c) {return Q (a, b, c)}, REMOVEDATA: function (a, b) {return R (a, b)}, _ datos: function (a, b, c) {return Q (a, b, c, 0)}, _ REMOVEDATA! : function (a, b) {return R (a, b, 0!)}}), m.fn.extend ({datos: function (a, b) {var c, d, e, f = esta [0 ], g = f && f.attributes; si (void e} return "objeto" == typeof 0}, REMOVEDATA: function (a) {return this.each (function () {m.removeData (esto, a)})}}), m.extend ({cola: la función (a, b, c) {var d; retorno 0}, dequeue: function (a, b) {b = b || "fx"; var f.stop, e.call (a, g, f)) ,! d && f && f.empty.fire ()}, _ queueHooks: function (a, b) {var c = b + "queueHooks"; volver m._data (a, c) || ​​m._data (a, c, {vacías: m.Callbacks ("una vez !? c = 2; return "cadena" = typeof un && (b = a, a = "fx", c -), arguments.length <c m.queue (este [0], a): void 0 == = B este:? this.each (function () {var this.each (function () {m.dequeue (esto, a)})}, clearQueue: function (a) {return this.queue (un "fx" || [])}, promesa: la función (a, b) {var c, d = 1, e = m.Deferred (), f = esto, g = this.length, h = function () {- d || e.resolveWith (f, [f])} ; "cadena" = typeof un && (b = a, a = nula 0), a = a || "fx";! while (g -) c = m._data (f [g], A + "queueHooks") , c && c.empty && (d ++, c.empty.add (h)); retorno h (), e.promise (b)}}); var h = 0, i = a.length, j = null == c; si ("objeto" === m.type (c)) {e = 0;! a (h en c) m.access (a, b, h, c [h] ,! 0, f, g)} else if (void 0! == d && (e = 0, m.isFunction (d) || (g = 0), j && (g ? (b.call (a, d), b = null) :( j = b, b = function (a, b, c) {j.call retorno (m (a), c)})), b) ) para (; i> h; h ++) b (a [h], c, g d:? d.call (a [h], h, b (a [h], c))?); vuelvo un correo ??: j b.call (a): i b (a [0], c): f}, W = / ^ (?: casilla | Radio) $ / i; function () {var a = y!. createElement ("entrada"), b = y.createElement ("div"), c = y.createDocumentFragment (), si (b.innerHTML = "<link /> <table> </ table> <a href =" / un "> una </a> <input type = "radio" verificado = 'controlada' b.test} catch (d) {k.deleteExpando = 1}}} (), function () {var b, c, d = y.createElement ("div"), porque (b en {presentar: 0 , cambie: 0, focusIn: 0}) c ​​= "on" + b, (k [b + "Burbujas"] = c en a) || (d.setAttribute (c, "t"), k [b + "Burbujas"] = d.attributes [c] .expando === 1);! d = null} (); var aa () {! volver 0} function ba () {! devolver 1} function ca () {try {return y.activeElement} catch (a) {}} = {m.event mundial: {}, añadir: function ( a, b, c, d, e) {var typeof m === K || un && m.event.triggered === a.type? vacío k [o])} else para (o en k) m.event.remove (a, o + b [j], c, d, 0);! m.isEmptyObject (k) && (borrar r.handle, m ._removeData (a, "eventos"))}}, disparador: function (b, c, d, e) {var m.Event (p, "objeto" == typeof b && b), b.isTrigger = e 2: 3, b.namespace = q.join ("."), b.namespace_re = b.namespace nueva RegExp ("? (^ | \\). "+ q.join (" \\ (:.?.. * \\ |) ") +" (. \\ | $) "): null, b.result = vacío 0, l && (d [g] = l)} return b.result}}, expedición: function (a) {a = m.event.fix (a); var 0! == C && (a.result = c) ===! 1 && (a.preventDefault (), a.stopPropagation ()))} volver k.postDispatch && k.postDispatch.call (esto, a), a.result} }, manipuladores: función (a, b) {var ",vacío h <b.length && g.push ({elem: esto, manipuladores: b.slice (h)}), g}, fijar: function (a) {if (a [m.expando]) devuelve una; var m.Event (f), b = D.Longitud, mientras que (b -) c = d [b], una [c] = f [c]; retorno burbujas cancelable ctrlKey currentTarget eventPhase metakey relatedTarget shiftKey vista timeStamp objetivo que ".split (" "), fixHooks: {}, keyHooks: {props:" charCode carbón keyCode clave ".split (" "), el filtro: function (a, b ) {return null == a.which && (a.which = null = b.charCode b.charCode:!? b.keyCode), un}}, mouseHooks: {props: "buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement ".split (" "), el filtro: function (a, b) {var c, d, e, f = b.button, g = b.fromElement; retorno this.focus () ,! 1} catch (a) {}}, delegateType: "focusIn"}, mancha: {gatillo: function () {return este === ca () && this.blur (this.blur (? ) ,! 1): void 0}, delegateType: "focusOut"}, haga clic en: {gatillo: function () {return m.nodeName (this, "entrada") && "casilla" === this.type && this.click? (this.click () ,! 1): void 0}, _ por defecto: function (a) {return m.nodeName (a.target, "a")}}, beforeunload: {postDispatch: function (a) {void e = m.extend (nueva d = "on" + b; a.detachEvent && (typeof un [d] === K && (a [d] = null), a.detachEvent (d, c))}, m.Event = function (a, b ) {return este instanceof m.nodeName (esta "forma",) ?! 1: void m.event.add (esto "click._submit keypress._submit", la función (a) {var b = a.target, c = m.nodeName ( ? b, "entrada") || m.nodeName (b, "botón") b.form: void m.nodeName (this, "forma") ?! 1: void m.event.remove (esto "._ enviar")}}), k.changeBubbles || (m.event.special.change = {configuración: función (){regreso m.event.add (esto "beforeactivate._change", la función (a) {var b = a.target; retorno 0}, desmontaje: function () {return f, g; if (! "objeto" == typeof a) {"cadena" = typeof b && (c = c || b, b = 0 nula), porque (f en a) this.on (f, b, c, a [f], e); devuelva este} if (? nula == c && nula == d (d = b, c = b = 0 nula): null == d && ("cadena" == typeof b (? d = c, c = 0 nula) :( d = c, c = b, b = void 0)), d === 1) d = ba;! else if (d) devolver este; return 1 == = e && (g = d, d = function (a) {return this.on (a, b, c, d, 1)}, off: la función (a, b, c) {var d, e; si (a && && a.preventDefault a.handleObj) de retorno a) {for (e en a) this.off (e, b, a [e]); devuelva este} return (b === 1 || "función" == typeof b) && (c = b,! ! b = nula 0), c === 1 && (c = ba), this.each (function () {m.event.remove (esto, a, c, b)})}, disparador: la función (a, b) {return this.each (function () {m.event.trigger (a, b, este)})}, triggerHandler: function (a, b) {var c = esta [0]; retorno c m?. event.trigger (a, b, c, 0!): void 0}}); función da (a) {var c} var jQuery \ d + = "(nulo ?: | \ d +)" / g, ga = new ua (a, b) {var c, d, e = 0, f = typeof a.getElementsByTagName == K a.getElementsByTagName (b || "*"):!?! typeof a.querySelectorAll == K a?. querySelectorAll (b || "*"): void void 0 === b || b && m.nodeName (a, b) m.merge ([a], f): f} function va (a) {W.test (a.type) && (a.defaultChecked = a.checked)} wa de función (a, b) {return xa (a) {return a.type = (null! == m.find.attr (a, "tipo")) + "/" + a.type, a} funcionar ya (a) {var b = pa. ? exec (a.type); retorno b = a.type b [1]: a.removeAttribute ("tipo"), un} za la función (a, b) {for (var c, d = 0; null = (c = a [d]); d ++) m._data (c, "globalEval", b || m._data (b [d] ", globalEval"!))} Aa función (a, b) {if ( 1 === b.nodeType && m.hasData (a)) {var c, d, e, f = m._data (a), g = m._data (b, f), h = f.events; si (h ) {borrar g.handle, g.events = {}; for (c en Ba (a, b) {var en Aa (a, f); retorno h = null, o}, CleanData: function (a, b) {for (var en g.events) n [e] m.event.remove (d, e):?? m.removeEvent (d, e, g.handle); j [f] && (borrar j [f], l eliminar d [i]: typeof V (esto, la función (a) {void retorno this.domManip (argumentos, la función (a) {if (1 === === this.nodeType || 11 || 9 this.nodeType === this.nodeType) {var b = wa (esto, a); b.appendChild (a)}})}, anteponga: function () {return this.domManip (argumentos, la función (a) {if (1 === === this.nodeType || 11 || 9 this.nodeType === this.nodeType) {var b = wa (esto, a); b.insertBefore (a, b.firstChild)}})}, antes: function () {return esto}, vacío: function () {for (var esto}, clon: function (a, b) {return una = null == 1:?! a, b = null == b a: b, this.map (function () {m.clone retorno (esta , a, b)})}, html: function (a) {return V (esto, la función (a) {var b = esta [0] || {}, c = 0, d = this.length; si ( void 0 === a) la devolución 1 === b.nodeType b.innerHTML.replace (fa, "?"): void 0; if (("cadena" = typeof a = argumentos [0]; retorno this.remove (a, 0!)}, domManip: function (a, b) {a = e.apply ([], a); var c, d, f, g, h, i, j = 0, l = this.length, n = este, o = l-1, p = a [0], q = m.isFunction (p); if (! q || l> 1 && "cadena" == typeof p && && k.checkClone na .test (p)) volver this.each (function (c) {var this.pushStack (e)}}); var Ca, Da = {}; función de Ea (b, c) {var e.detach (), f} function Fa (a) {var b = y, c = Da [a]; retorno c || (c = Ea (a, b), "ninguno" == c && c || (! Ca = (Ca || m ("<'0' width iframe frameborder = = '0' a; k.shrinkWrapBlocks = function () {if (null = a!) volver a; a = 1;! var b, c, d; retorno 0}} (); var Ga = / ^ margen /, Ha = new ? d, e, f, g, h = a.style; retorno c = c || Ia (a), g = c c.getPropertyValue (b) || c [b]: void 0 === g g: g + ""}): y.documentElement.currentStyle && (Ia = function (a) {return a.currentStyle}, Ja = function (a, b, c) {var d, e, f ?, g, h = a.style; retorno c = c || Ia (a), g = c c [b]: void 0 === g g: g + "" || "auto"}); La función de (a, b) {return {get: function () {var c = a (), si (null = c) de regreso! ? c nula eliminar this.get: (this.get = b) .apply (esto, argumentos)}}} function () {var b, c, d, e, f, g, h, y si (b = y! .createElement ("div"), b.innerHTML = "<link /> <table> </ table> <a href='/a'> un </a> <input "=== c.MozBoxSizing ||" "=== c.WebkitBoxSizing, m.extend (k, {reliableHiddenOffsets: function () {return nula == g && i (), g}, boxSizingReliable: function () {return null == f && i (), f}, pixelPosition: function () {return null == e && i (), e}, reliableMarginRight: function () {return && i (), h}}) null == h; la función i () { var e, f, g = {}; para (f en b) g [f] = a.style [f], a.style [f] = b [f]; e = c.apply (a, d || []), porque (f en b) a.style [f] = g [f]; retorno e}; var Ma = / alfa \ ([^)] * \) / i, Na = / opacidad \ s * = \ s * ([^)] *) /, Oa = / ^ (ninguno |?! tabla (- c [ea]). +) /, Pa = new RegExp ("^ (" + S + ") (. *) $ "," i "), Qa = new Ua (a, b) {if (b en a) la devolución b; var c = b.charAt (0) .toUpperCase () + b.slice (1), d = b, e = Ta.length, mientras que (e -) si (b = Ta [e] + c, b en a) la devolución b; retorno d} function Va (a, b) {for (var a} función Wa (a, b, c) {var d = Pa.exec (b); retorno d Math.max (0, d [1] - (c || 0)) + (d [2] |? | "px"): b} function Xa (a, b, c, d, e) {for (var g función} Ya (a, b, c) {var e; d = g && (k.boxSizingReliable () || e === a.style [b]), e = parseFloat (e) || 0} return 0 === c) retorno g && "get" en g && vacío 0 == (e = g.get (a, 1, d!)) E:!? I [b]; si (f = typeof g && void 0 === (c = g.set (a, c, d))))) tratan {i [b] = c} catch (j) {}}}, css: function (a, b, c, d) {var e, f, g, h = m.camelCase (b); retorno b = m.cssProps [h] || (m.cssProps [h] = Ua (a.style, h)), g = m.cssHooks [b] || m.cssHooks [h], g && "get" en g && (f = g.get (a, 0, c)), nula 0 === f && (f = Ja (a, b, d)), "normal" === && f b en ? c Oa.test (m.css (un "display")) && 0 === a.offsetWidth m.swap (a, Ra, la función () {return Ya (a, b, d)}): Ya (a, b, d): void 0}, establezca: function (a, c, d) {var e = d && Ia (a); retorno "+ E)}}), m.cssHooks.marginRight = La (k.reliableMarginRight, la función (a, b) {return b m.swap (a, {display:" inline-block "}, Ja, [a "marginRight"]): void d = 0, e = {}, f = "cadena" == typeof c c.split (""):? [c]; 4> d; d ++) e [a T + [d] + b] = f [d] || f [d-2] || f [0]; volver e}}, Ga.test (a) || (m.cssHooks [a + b] .set = Wa)}), m. fn.extend ({css: function (a, b) {return V (esto, la función (a, b, c) {var d, e, f = {}, g = 0; si (m.isArray (b) ) {for (d = Ia (a), e = b.length; e> g; g ++) f [b [g]] = m.css (a, b [g] ,! 1, d), f retorno } return vacío 0 == c m.style (a, b, c):? m.css (a, b)}, a, b, arguments.length> 1)}, espectáculo: function () {return Va (esto, 0!)}, ocultar: function () {return Va (este)}, de palanca: function (a) {return "booleano" == typeof a a this.show ():?? this.hide () ({? U (esto) m (esto) .show (): m (esto) .hide ()} function ()): this.each}}); función Za (a, b, c, d, e) {
volver nueva Za.prototype.init (a, b, c, d, e)} m.Twa = Za.propHooks [this.prop]; devolver un && a.get a.get (este): Za.propHooks._default.get (este)}, ejecute: function (a) {var b, c = Za.propHooks? [this.prop]; retorno b; retorno a}, columpio: function (a) {return.5-Math.cos (a * Math.PI) / 2}}, m.fx = Za.prototype.init, m.fx.step = {}; var $ una, _a, ab = / ^ (?: basculante | presentación | ocultar) $ /, bb = nueva RegExp ("^ (:? ([+ -]) = |) (" + S + ") ([az%] *) $ "," i "), cb = / queueHooks $ / db = [ib], eb = {" * ": [función (a, b) {var h = h || "0.5", g / = h, m.style (c.elem, a, g + f);! while (h == (h = c.cur () / d) && 1 = = h && - i)} return e && (? g = c.start = + g + d || || 0, c.unit = f, c.end = e [1] g + (e [1] 1) * e [2]: + e [2]), c}]}; función fb () {return setTimeout (function () {$ a = void 0}), $ a = m.now ()} gb de función ( a, b) {var c, d = {height: a}, e = 0; para (b = b 1: 0; 4> e; e + = 2-b) c = T [e], d [" margen "+ c] = d [" relleno "+ c] = a; retorno b && (d.opacity = d.width = a), d} function hb (a, b, c) {for (var d, e = (eb [b] || []) concat (eb ["*"]), f = 0, g = e.length;. g> f; f ++) si (d = e [f] .call (c, b, a)) return d} ib función (a, b, c) {var b || "ancho" en en b) si (E = b [d], ab.exec (e)) {if (borrar b [d], f = f || "alternar" === e, e === (q? "ocultar ":" show ")) {if ("!!! espectáculo "== e || r || vacío 0 === r [d]) continuar; q = 0} o [d] = r && r [d] | | m.style (a, d)} else j = 0 nula; si (m.isEmptyObject (o)) "en línea" === ("ninguno" === j Fa (a.nodeName): j) && (p.display = j), else {r "escondido" en? b; m._removeData (a, "fxshow"), porque (b en o) m.style (a, b, o [b])}); for (d en o) g = hb (r q [d ]: 0, d, n), d en r || (r [d] = g.start, q && (g.end = g.start, g.start = "width" === d || "altura" ? === d 1: 0))}} function jb (a, b) {var c, d, e, f, g, porque (c en a) si (d = m.camelCase (c), e = b [d], f = a [c], m.isArray (f) && (e = f [1], f = a [c] = f [0]), c! == d && (a [d] = f, eliminar un [c]), g = m.cssHooks [d], g && "ampliar" en g) {f = g.expand (f), eliminar un [d]; para (c en f) c en a || (a [c] = f [c], b [c] = e)} else b [d] = e} function kb (a, b, c) {var d, e, f = 0 g, . = db.length, h = m.Deferred () siempre (function () {delete i.elem}), i = function () {if (e) volver 1;! for (var d = m.Tween (a, j.opts, b, c, j.opts.specialEasing [b] || j.opts.easing); j.tweens.push retorno (d), d}, parada: function ( b) {var c = 0, d = b j.tweens.length: 0; si (e) volver esto, porque (e = 0, d> c, c ++) j.tweens [c] .run (1 );regreso d; retorno "); for (var d = un "objeto" && == typeof d.duration = m.fx.off 0:?? "número" == d.duration typeof d.duration: d.duration en e = m.isEmptyObject (a), f = m.speed (b, c, d), g = function () {var b = kb (esto, m.extend ({}, a), f), (e || m._data (this, "terminar")) && b.stop (0)}; volver g.finish = g, e || f.queue === 1 this.each (g): esto!?. cola (f.queue, g)}, pare: function (a, b, c) {var d = function (a) {var b = a.stop; eliminar a.stop, b (c)}; volver "cadena "! = typeof un && (c = b, b = a, a = nula 0), b && a! ==! 1 && this.queue (a ||" fx ", []), this.each (function () {var b !! = 0, e = null = a && a + "queueHooks", f = m.timers, g = m._data (este), si (e) g [e] && g [e] .Stop && d (g [e]); más para (e en a! ==! 1 && (a = a || "fx"), this.each (function () {var c.finish})}}), m.each (["cambiar", "show", "ocultar"], la función (a, b) {var c = m.fn [b]; m.fn [b] = function (a, d, e) {return null == a || "booleano" == typeof this.animate (b, a, c, d)}}), m.timers = [], m.fx.tick = function () {var a = m.fx m.fx.speeds [a] || a:? a, b = b || "fx", this.queue (b, la función (b, c) {var d = setTimeout (b, a ); c.stop = function () {clearTimeout (d)}})}, function () {var a, b, c, d, e, b = y.createElement ("div"), b.setAttribute (" className "," t "), b.innerHTML =" <link /> <table> </ table> <a href='/a'> un </a> <input libra = / \ r / g; m.fn.extend ({val: function (a) {var b, c, d, e = esta [0]; {if (arguments.length) retorno d = m.isFunction ( a), this.each (function (c) {var e; 1 === this.nodeType && (e = d a.call (esto, c, m (este) .val ()):? a, == null e e = "?": "número" == typeof e e + =? "": m.isArray (e) && (e = m.map (e, la función (a) {return null == un ""?: a + ""})), b = m.valHooks [this.type] || m.valHooks [this.nodeName.toLowerCase ()], b && "set" en b && vacío 0! == b.set (esto, e, "valor") || (this.value = e))}); if (e) de retorno b = m.valHooks [e.type] || m.valHooks [e.nodeName.toLowerCase ()], b && "consiguen "en b && vacío 0 == (c = b.get (e," valor ")) c:? (c = e.value," cadena "== typeof c c.replace (libras,?" "): null ? == c "": c)}}}), m.extend ({valHooks: {opción: {llegar: function (a) {var b = m.find.attr (a, "valor"); return null ! = b b:? m.trim (m.text (a))}}, seleccione: {get: function (a) {for (var b; g.push (b)} return g}, establezca: function (a, b) {var d.selected = 1;! devolución ? m.isArray (b) a.checked = m.inArray (m (a) .val (), b)> = 0: void 0}}, k.checkOn || (m.valHooks [esto] .get = función (a) {return null === a.getAttribute ("valor") "en": a.value?})}); var V (esto, m.attr, a, b, arguments.length> 1)}, removeAttr: function (a) {return this.each (function () {m.removeAttr (esto, a)})}}), m.extend ({attr:!!! función (a, b, c) {var d, e, f = a.nodeType; si (a && 3 == f && 8 == f && 2 == f) la devolución typeof 0 === c d && "get" en d && nula == (e = d.get (a, b)) e:?!?? (E = m.find.attr (a, b), == null e vacío 0: e): nula == c d && "set" en d && vacío 0 == (e = D.SET (a, c, b)) e:?!? (a.setAttribute (b, c + ""), c): void m.removeAttr (a, b))}, removeAttr: function (a, b) {var c = a.value; volver a.setAttribute ("tipo", b), c && (a.value = c), b}}}}}), nb = {conjunto: function (a, b, c) {return c = OB [b] || m.find.attr; ob [b] = rb && qb || pb.test (yb) la función de (a, b, d) {var e, f;!? retorno d || (f = ob [b], ob [b] = E, E = null = c (a, b, d) b.toLowerCase ():!? nulos, ob [b] = f), e}: la función (a, b, c) {return c? nula m.nodeName (a, "entrada") vacío (a.defaultValue = b):? mb && mb.set (a, b, c)}}), qb || (mb = {conjunto: function (a, b, c ) {var d = a.getAttributeNode (c); retorno 0}}, ob.id = ob.name = ob.coords = function (a, b, c) {var d; c retorno void 0: (d = a.getAttributeNode (b)) && "" ==?! ? d.value d.value: null}, m.valHooks.button = {get: function (a, b) {var c = a.getAttributeNode (b); volver c && c.specified c.value: void 0}}})), k.style || (m.attrHooks.style = {get: function (a) {return a.style.cssText || vacío 0}, establezca: function (a, b) {return un .style.cssText = b + ""}}); var V (esto, m.prop, a, b, arguments.length> 1)}, removeProp: function (a) {return a = m.propFix [a] || a, this.each (function () {try { esto [a] = 0 vacío, eliminar d, e, f, g = a.nodeType;! if (!!! un && 3 == g && 8 == g && 2 == g) return f = 1 == g || m.isXMLDoc (a), f && (b = m.propFix [b] || B, E = m.propHooks [b]), nula 0! == c? e && "set" en e && vacío 0! == (d = e.set (a, c, b) ) d:? A [B] = c: e && "get" en e && nula == (d = e.get (a, b)) d:? A [B]}, propHooks: {tabIndex: {get: función (a) {var b = m.find.attr (a, "tabindex"); retorno a.getAttribute (b, 4)}}}), k.optSelected || (m.propHooks.selected = {get: function (a) {var b = a.parentNode; retorno ub = / [\ t \ r \ n \ f] /g;m.fn.extend ({addClass: function (a) {var b, c, d, e, f, g, h = 0, i = presente .length, j = "cadena" == typeof un && a; si (m.isFunction (a)) return "+ c.className +" ") .Colocar (ub", "):" ")) {f = 0, mientras que (e = b [f ++]) d.indexOf (" "+ e +" ") <0 && (d + = e + ""); g = m.trim (d), c.className == g && (c.className = g)}} devolver este, removeClass: función (a) {var b, c, d, e, f, g, h = 0, i = this.length, j = 0 === arguments.length || "cadena" == typeof un && a; si (m.isFunction (a)) return "+ c.className +" ") .Colocar (ub", "):" ")) {f = 0, mientras que (e = b [f ++]), mientras que (d.indexOf (" "+ e +" ")> = 0) d = d.replace ("" + e + "", ""); g = a m.trim (d): "!", c.className == g && (c.className = g)} devuelva este }, toggleClass: function (a, b) {var c = typeof a; "booleano" retorno == typeof b = "" + a + "", c = 0, d = this.length; d> c, c ++) si (1 === esta [c] .nodeType && ("" + este [c] .className + "") .Colocar (ub, "") .indexOf (b)> = 0) return 0;! devolver 1}}), m.each ("enfoque desenfoque focusIn carga focusOut desplazamiento de cambio de tamaño de descarga, haga clic dblclick mousedown mouseup mousemove mouseover mouseout MouseEnter mouseleave Cambiar Seleccionar presentar pulsación keydown error keyup contextual ".split (" "), la función (a, b) {m.fn [b] = function (a, c) {arguments.length retorno> 0? this.on (b, nulo, a, c): this.trigger (b)}}), m.fn.extend ({vuelo estacionario: function (a, b) {return this.mouseenter (a) .mouseleave (b || a)}, bind: function (a, b, c) {return this.on (a, nula, b, c)}, desenlaza: function (a, b) {return this.off (a, nulo, b)}, delegado: función (a, b, c, d) {return this.on (b, a, c, d)}, undelegate: function (a, b, c) {return 1 === arguments.length this.off (? un, "**"): this.off (b, a || "**", c)}}); var a.JSON.parse (b + ""); var c, d = null, e = m.trim (b + ""); volver e && m.trim (e.replace (xb, la función (a, b, e,! f) {return c && b && (d = 0), 0 === d a:?!! (c = e || b, d + = f- e ",")}?)) Función ("retorno" + e) (): m.error ("JSON válido:" + b)}, m.parseXML = function (b) {var c, d, y si (b || "cadena" = typeof b!) null retorno; try { a.DOMParser? (d = new DOMParser, c = d.parseFromString (b, "text / xml")) :( c = new ActiveXObject ("Microsoft.XMLDOM"), c.async = "false", c.loadXML (b))} catch (e) {c = nula 0} return c && && c.documentElement c.getElementsByTagName ("parsererror") Longitud || m.error ("XML no válido:" + b), c}; var yb!. ., zb, Ab = / # * $ /, Bb = / ([? &]) _ = [^ &] * /, Cb = / ^ (*.?): [ ! Lb (a) {retorno de la función (b, c) {"cadena" = typeof b && (c = b, b = "*"); var Mb (a, b, c, d) {var e = {}, f = a === Ib; función g (h) {var i; vuelta de correo [h] = 0, m.each (a [h! ] || [], la función (a, h) {var j = h (b, c, d);?!?! regresan "cadena" = typeof j || f || e [j] i (i = j ): void 0: (b.dataTypes.unshift (j), g (j) ,! 1)}), i} return g (b.dataTypes [0]) || e ["*"] && g ("! * ")} function Nb (a, b) {var C, D, E = m.ajaxSettings.flatOptions || {};! a (d en b) vacío 0 == b [d] && ((e [d ] a:?! c || (c = {})) [d] = b [d]); volver c && m.extend (0, a, c), un} function Ob (a, b, c) {var d, e, f, g, h = a.contents, i = a.dataTypes; mientras ("*" === i [0]) i.shift (), nula 0 === e && (e = a. mimeType || b.getResponseHeader ("Content-Type")); si (e) para (g en h) si (h [g] && h [g] .test (e)) {i.unshift (g); ruptura } if (i [0] en c) f = i [0]; (! i [0] || a.converters [g + "" + i [0]]) else {for (g en c) {if { f = g; ruptura} d || (d = g)} f = f || d} return f (f == i [0] && i.unshift (f), c [f]!): void 0} función de Pb (a, b, c, d) {var e, f, g, h, i, j = {}, k = a.dataTypes.slice (), si (k [1]) para (g en si ("*"! == i && i! == f) {if (g = j [i + "" + f] || j ["*" + f] ,! g) de (e en j) si (h = e.split (""), h [1] === f && (g = j [i + "" + h [0]] || j ["* try {b = g (b)} catch (l) {return {estado: "parsererror", error:? g l: "Sin la conversión de" + i + "para charset = UTF-8 ", acepta: {" * ": Jb, texto:" text / plain ", html:" text / html ", xml:" application / xml, text / xml ", json:" application / json , texto ": String", html texto ": 0," json texto ": m.parseJSON," xml texto ": m.parseXML}, flatOptions: {url: 0, el contexto: 0}}, ajaxSetup: función (a, b) {return un && (b = a, a = 0 nula), b = b || {}; var b, y si (2 === t) {if (j!) {j = {}, mientras que (b = Cb.exec (f)) j [b [1] .tolowercase ()] = b [2]} b = j [a.toLowerCase ()]} devolver null == b nula:? b}, getAllResponseHeaders: function () {return 2 === t f: null}, setRequestHeader: function (a, b) {var c = a.toLowerCase (); retorno t || (a = s [c] = s [c] || a, r [a] = b), esto}, overrideMimeType: function (a) {return t || (k.mimeType = a), esto}, StatusCode: function (a) {var b; si (a) si (2> t) para (b en a) q [b] = [q [b], una [ b]]; v.always demás (a [v.status]); regresan este}, abortar: function (a) {var b = a || u; retorno k.data && (k.data = m.param (k.data, k.traditional)), Mb (Hb, k, b, v), 2 === t) de retorno "+ Jb +"; q = 0.01 ":" "): k.accepts [" * "]); para (d en v.abort (); u = "abortar", porque (d w; x (-1, w)}} else x (-1, "No Transport"); función x (a, b, c, d) {var j, r, s, u, w, x = b; 2! == t && (t = 2, g && clearTimeout (g), i = vacío v}, getJSON: function (a, b, c) {return m.get (a, b, c, "json")}, getScript: function (a, b) {m.get retorno (a, 0 nula, b,)}}), m.each (["get", "post"], la función de "guión" (a, b) {m [b] = function (a, c, d, e) {return m. isFunction (c) && (e = e || d, d = c, c = 0 nula), m.ajax ({url: una, escriba: b, Tipo de datos: correo, los datos: c, el éxito: d})} }), m._evalUrl = function (a) {return this.each (function (b) {m (esto) .wrapAll (a.call (esto, b))}), si (esta [0]) {var a = este, mientras que (a.firstChild && 1 === a.firstChild.nodeType) a = a.firstChild; volver a}) append (este)}} devuelva este, wrapInner:. función (a) {return this.each ( ? m.isFunction (a) la función (b) {m (este) .wrapInner (a.call (esto, b))}: function () {var b = m (este), c = b.contents (); ? c.length c.wrapAll (a): b.append (a)})}, envoltura: function (a) {var b = m.isFunction (a); volver this.each (function (c) {m ( esto) .wrapAll (b a.call (esto, c?): function () {return: a)})}, desenvuelva Vb (a, b, c, d) {var correo; si (m.isArray (b)) m.each (b, la función (b, e) {c || Rb.test (a) d (a,? e): Vb (a + "[" + ("objeto" == typeof e b:? "") + "]!", e, c, d)}); else if (c || "objeto" == m.type (b)) d (a, b); más para (e en b) Vb (a + "[" + e + "]", b [e], c, d)} m.param = function (un , b) {var para (c en a) Vb (c, a [c], b, e); volver d.join ("&") reemplazará (Qb, "+")}, m.fn.extend ({serialize:. función () {return m.param (this.serializeArray ())}, serializeArray: function () {return this.map (function () {var a = m.prop (this, "elementos"), devuelve un m?. MakeArray (a):. esta}) filtrar (function () {var a = this.type; retorno c = m (este) .val (); retorno Wb = 0, Xb = {}, Yb = m.ajaxSettings.xhr ();! A.attachEvent && a.attachEvent ("onunload", function () {for (var a en Xb) Xb [a] (void 0, 0 )}), k.cors = !! Yb && "withCredentials" en Yb, Yb = k.ajax = !! Yb, Yb && m.ajaxTransport (function (a) {if (! a.crossDomain || k.cors) {var b; retorno {enviar: function (c, d) {var e, f = a.xhr (), g = ++ Wb; si (f.open (a.type, a.url, a.async, a. nombre de usuario, a.password), a.xhrFields) para (e en en c) void 0 == c [e] && f.setRequestHeader (e, c [e] + "");! f.send (a.hasContent && a.data || null), b = function (c, e) { var h, i, j; if (b && (e || 4 === f.readyState)) si (borrar Xb [g], b = 0 vacío, f.onreadystatechange = m.noop, e) 4 == f.abort f.readyState && (); else {j = {}, h = f.status, "cadena" == typeof 0, 0)}}}}); función Zb () {try {return new a.XMLHttpRequest} catch (b) {}} function $ b () {try {return new a.ActiveXObject ("Microsoft.XMLHTTP" )} catch (b) {}} m.ajaxSetup ({acepta: {script: "text / javascript, application / javascript, application / ECMAScript, application / x-ECMAScript"}, contenidos: {script: / (?: java | ECMA) script /}, convertidores: {"escritura de texto": function (a) {return m.globalEval (a), un}}}), m.ajaxPrefilter ("guión", la función (a) {void ?!? 0, 0)}}}}); _b var = [], ac = / (=) \ (= & | $) | \ \ /; m.ajaxSetup ({jsonp:?? "Devolución de llamada", jsonpCallback: function () {var a = _b.pop () || m.expando + "_" + vb ++; devuelva este [a] = 0, a!}}), m.ajaxPrefilter ("json jsonp", función ( b, c, d) {var e, f, g, h = b.jsonp == 1 && (ac.test (b.url) "url":!? "cadena" == typeof json "] = function () {return g || m.error (e +" no era 0}), "script"):!! Nula 0}), m.parseHTML = function (a, b, c) {if (a || "cadena" = typeof a) nula rentabilidad; "booleano" == typeof b && (! c = b, b = 1), b = b || y; var d = u.exec (a), e = c && [];! devolución bc = m.fn.load; m.fn.load = function (a, b, c) {if ("cadena" = typeof un && aC!) volver bc.apply (esto, argumentos); var d, e, f, g = esto, h = a.indexOf (""); retorno h> = 0 && (d = m.trim (a.slice (h, a.length)), a = a.slice (0, h)), ? m.isFunction (b) (c = b, b = nula 0): b && "objeto" == typeof this.on (b, a)}}), m.expr.filters.animated = function (a) {return m.grep (m.timers, la función (b) {return un b.elem ===}). longitud}; var cc = a.document.documentElement; función dc (a) {return b b.using.call (a, n):? l.css (n)}}, m.fn.extend ({offset: la función (a) {if (arguments.length) de retorno void 0 === una? esto: this.each (function (b) {m.offset.setOffset (esto, a, b)}); var b, c, d = {superior: 0, izquierda: 0}, e = esta [0], f = e && e.ownerDocument; si (f) de retorno b = f.documentElement, m.contains (b, e) (typeof? this.map (function () {var un cc ||})}}), m.each ({scrollLeft: "pageXOffset", scrollTop: "pageYOffset"}, la función (a, b) {var c = / Y / .test (b); m.fn [a] = function (d) {return V (esto, la función (a, d, e) {var f = dc (a); volver vacío 0 === e f b en? ? c (? c = Ja (a, b), Ha.test (c) m (a) .position () [b] + "px": c): void f = arguments.length && (c || "booleano" = typeof d!), g = c || (d === 0 || e === 0 "margen":!? "frontera"); volver V (esto, la función (b, c, d) {var e; retorno ? 0 === d m.css (b, c, g):? M.style (b, c, d, g)}, b, f d: void 0, f, null)}})}), m.fn.size = function () {return this.length}, m.fn.andSelf = m.fn.addBack, "función" == definir typeof && && define.amd define ("jQuery", [], la función () {return m}); var ec = a.jQuery, fc = a $;. regresar m.noConflict = function (b) {return un $ === m && (a $ = fc), b && a.jQuery === m &&.. (a.jQuery = ec), m}, typeof b === K && (a.jQuery = a $ = m.), m});
